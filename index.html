<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.3.1/p5.js"></script>
<script src="gl_utils.js"></script>
<script src="main.js"></script>

<body bgcolor=white>
<canvas id='canvas1' width='800' height='800'>
</canvas>
</body>

<script id="vs" type="x-shader/x-vertex">
   attribute vec3 aPosition;
   varying   vec3 vPosition;
   void main() {
      gl_Position = vec4(aPosition, 1.0);
      vPosition = aPosition;
   }
</script>

<script id="fs" type="x-shader/x-fragment">
    precision mediump float;
    uniform float uTime;
    varying vec3 vPosition;
    uniform vec3 uCursor;
    const int NUM_OBJECTS = 64;
    uniform vec4  pos[NUM_OBJECTS];   //objects position + radius
    uniform vec3  col[NUM_OBJECTS];   //object color
    uniform vec3 cPos; // camera position
    vec3 color = vec3(0,0,0);

    struct Sphere {
        vec3 center;
        float radius;
        vec3 color;
    };

    struct Ray {
        vec3 origin;
        vec3 direction;
    };

    struct Light {
        vec3 position;
        float ambience;
        vec3 specular;
        vec3 diffuse;
    };

    struct Voxel{
      vec3 min;
      vec3 max;
      vec3 color;
      bool isInit;
    };


    Voxel voxels[128];
    Ray rays[1];
    Light light[1];

    vec2 intersectVoxel(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax) {
      vec3 tMin = (boxMin - rayOrigin) / rayDir;
      vec3 tMax = (boxMax - rayOrigin) / rayDir;
      vec3 t1 = min(tMin, tMax);
      vec3 t2 = max(tMin, tMax);
      float tNear = max(max(t1.x, t1.y), t1.z);
      float tFar = min(min(t2.x, t2.y), t2.z);
      return vec2(tNear, tFar);
    }

    vec3 getVoxelNormal(vec3 hit, Voxel voxel){
      if(abs(hit.x-voxel.min.x)  < 0.01){
        return vec3(-1,0,0);
      }
      else if(abs(hit.x-voxel.max.x)  < 0.01){
        return vec3(1,0,0);
      }
      else if(abs(hit.y-voxel.min.y)  < 0.01){
        return vec3(0,-1,0);
      }
      else if(abs(hit.y-voxel.max.y)  < 0.01){
        return vec3(0,1,0);
      }
      else if(abs(hit.z-voxel.min.z)  < 0.01){
        return vec3(0,0,-1);
      }
      else if(abs(hit.z-voxel.max.z)  < 0.01){
        return vec3(0,0,1);
      }
      else{
        return vec3(0,0,0);
      }
    }

    vec3 rayPos(Ray ray,float t){
      return ray.origin + ray.direction*t;
    }


    void initialize() {
        float x = vPosition.x;
        float y = vPosition.y;
        float z = vPosition.z;
        float focalLength = 2.0;
        vec3 color = vec3(0.0, 0.0, 0.0);
        // create voxels;
        
        voxels[0].min = vec3(-1.5,0.5,0);
        voxels[0].max = vec3(-0.5,1.5,1);
        voxels[0].color = vec3(1,1,1);
        voxels[0].isInit = true;



        // Create ray
        rays[0].origin = cPos;//vec3(0.0, 0.0, 4.0);
        rays[0].direction = normalize(vec3(x-0.5, 0.5-y, -focalLength));

        // Create Light source
        light[0].position = vec3(uCursor.x, -uCursor.y, 0.9);
        light[0].ambience = 0.01;
    }



    void main() {
        initialize();
        for(int i = 0; i< 128; i++){
          if(voxels[i].isInit == true){
            vec2 hit = intersectVoxel(rays[0].origin,rays[0].direction,voxels[i].min,voxels[i].max);
            if(hit.x < hit.y && hit.y > 0.0){
              vec3 hitLoc = rayPos(rays[0],hit.x);
              vec3 normal = getVoxelNormal(hitLoc,voxels[i]);
              gl_FragColor = vec4(vec3(abs(normal.x),abs(normal.y),abs(normal.z)), 1.0);
            }
            else{
              gl_FragColor = vec4(color, 1.0);
            }
          }
        }
   }
</script>

<script>
    start_gl("canvas1", getStringFromDOMElement('vs'), getStringFromDOMElement('fs'));
</script>

