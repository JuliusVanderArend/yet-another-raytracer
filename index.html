<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.3.1/p5.js"></script>
<script src="gl_utils.js"></script>
<script src="main.js"></script>
<link href="style.css" rel="stylesheet" type="text/css" />
<body bgcolor=white>
<canvas id='canvas1' width='1280' height='720'>
</canvas>
</body>

<script id="vs" type="x-shader/x-vertex">
   attribute vec3 aPosition;
   varying   vec3 vPosition;
   void main() {
      gl_Position = vec4(aPosition, 1.0);
      vPosition = aPosition;
   }
</script>

<script id="fs" type="x-shader/x-fragment">
    precision mediump float;
    uniform float uTime;
    varying vec3 vPosition;
    float x;
    float y;
    float z;
    uniform vec3 uCursor;
    const int NUM_OBJECTS = 64;
    uniform vec3 cPos; // camera position
    uniform float randSeed; //cpu random seed
    uniform float thetaY;
    float seed;
    const float PI = 3.1415926535897932384626433832795;
    const int sampleCount =100;
    const float sf = 0.01;
    vec3 color = vec3(0.1,0.1,0.1);
    bool hasHit;
    struct Sphere {
        vec3 center;
        float radius;
        vec3 color;
    };

    struct Ray {
        vec3 origin;
        vec3 direction;
    };

    struct Light {
        vec3 position;
        vec3 color;
        float intens; 
    };

    struct Voxel{
      vec3 min;
      vec3 max;
      vec3 color;
      bool isInit;
      int matIndex;
      float reflectance;
    };

    struct Hit{
      Voxel voxel;
      float minDist;
      bool hasHit;
    };


    Voxel voxels[128];
    Light lights[8];
    Ray rays[1];

    vec2 intersectVoxel(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax) {
      vec3 tMin = (boxMin - rayOrigin) / rayDir;
      vec3 tMax = (boxMax - rayOrigin) / rayDir;
      vec3 t1 = min(tMin, tMax);
      vec3 t2 = max(tMin, tMax);
      float tNear = max(max(t1.x, t1.y), t1.z);
      float tFar = min(min(t2.x, t2.y), t2.z);
      return vec2(tNear, tFar);
    }


    vec3 getVoxelNormal(vec3 hit, Voxel voxel){
      vec3 offset = (vec3(mod(hit.x,2.0),mod(hit.y,2.0),mod(hit.z,2.0))-vec3(0.5))*0.0;
      if(abs(hit.x-voxel.min.x)  < 0.001){
        return vec3(-1,0,0) + offset;
      }
      else if(abs(hit.x-voxel.max.x)  < 0.001){
        return vec3(1,0,0)+ offset;
      }
      else if(abs(hit.y-voxel.min.y)  < 0.001){
        return vec3(0,-1,0)+ offset;
      }
      else if(abs(hit.y-voxel.max.y)  < 0.001){
        return vec3(0,1,0)+ offset; // there is a bug here with normals being fliped into the object, fix later
      }
      else if(abs(hit.z-voxel.min.z)  < 0.001){
        return vec3(0,0,-1)+ offset;
      }
      else if(abs(hit.z-voxel.max.z)  < 0.001){
        return vec3(0,0,1)+ offset;
      }
      else{
        return vec3(0,0,0);
      }
    }

    vec3 rayPos(Ray ray,float t){
      return ray.origin + ray.direction*t;
    }

    mat3 rotY(float theta){
      return mat3(cos(theta),0,sin(theta),
                  0,1,0,
                  -sin(theta),0,cos(theta)
      );
    }


    void initialize() {
        x = vPosition.x;
        y = vPosition.y;
        z = vPosition.z;
        float focalLength = 1.0;
        vec3 color = vec3(0.0, 0.0, 0.0);
        seed = randSeed;
        // create voxels;
        voxels[0] = Voxel(vec3(-50,0,-100),vec3(50,1,50),vec3(1,1,1),true,3,0.5); //floor
        voxels[1] = Voxel(vec3(-10,-20,-10),vec3(-9,0,10),vec3(1,0,0),true,1,0.5);
        voxels[2] = Voxel(vec3(9,-20,-40),vec3(10,0,10),vec3(0,1,0),true,1,0.5);
        voxels[3] = Voxel(vec3(-4,-20.0,-4),vec3(4,-17.0,4),vec3(2.5,2.25,2.0),true,1,0.5);
        voxels[4] = Voxel(vec3(-30,-20,-11),vec3(10,0,-10),vec3(1,1,1),true,2,0.5);
        voxels[5] = Voxel(vec3(-50,-20,-100),vec3(-49,0,sin(uTime)*20.0),vec3(1,1,1),true,1,0.5);
        voxels[6] = Voxel(vec3(-50,-20,-100),vec3(20,-18,50),vec3(1,1,1),true,1,0.5);
        voxels[7] = Voxel(vec3(-50,0,-100),vec3(0,-20,-90),vec3(1,0.1,0.1),true,2,0.5);
        voxels[8] = Voxel(vec3(-50,0,40),vec3(-30,-20,50),vec3(1,1,1),true,1,0.5);
        voxels[9] = Voxel(vec3(10,-100,0),vec3(40,0,30),vec3(1,1,1),true,1,0.5);
        voxels[10] = Voxel(vec3(-1,-10,0),vec3(3,0,4),vec3(1,1,1),true,1,0.5);


        // Create ray
        rays[0].origin = cPos;//vec3(0.0, 0.0, 4.0);
        rays[0].direction = rotY(thetaY) * normalize(vec3(x,-y, -focalLength));

        // Create Light source
        //lights[0] =  Light(vec3(100.0*cos(uTime+2.0),-4,100.0*sin(uTime+2.0),vec3(1,0.1,0.1),10.0);
        lights[1] =  Light(vec3(20.0*cos(uTime+1.0),-4,20.0*sin(uTime+1.0)),vec3(1,0.1,0.1),15.0);
        lights[2] =  Light(vec3(40.0*cos(uTime),-4,30.0*sin(uTime)),vec3(1,0.7,0.9),8.0);
        lights[3] =  Light(vec3(6.0*cos(uTime),-4,6.0*sin(uTime)),vec3(1.0,0.6,0.1),4.0);
        //lights[4] =  Light(vec3(-uTime+20.0,-12.0-6.0*cos(uTime),-30),vec3(0,1.0,0.2),10.0);
    }

    vec3 worldColor(float y){
      return vec3(max((y+0.2),0.2),max((y+0.2),0.2),max((y+0.2)*1.5,0.2))*0.6;
    }

    float random(float offset){
      return fract(sin((x+offset)*(y+2.0))*43758.5453123);
    }

    float random3(vec3 scale, float seed){
      return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);
    }

    vec3 randVec(float offset){
      return vec3(random(10.0+offset)-0.5,random(20.0+offset)-0.5,random(30.0+offset)-0.5);
    }

    vec3 cosineWeightedDirection(float seed, vec3 normal) {
      float u = random3(vec3(12.9898, 78.233, 151.7182), seed);
      float v = random3(vec3(63.7264, 10.873, 623.6736), seed+1.0);
      float r = sqrt(u);
      float angle = 6.283185307179586 * v;
          // compute basis from normal
      vec3 sdir, tdir;
      if (abs(normal.x)<0.5) {
        sdir = cross(normal, vec3(1,0,0));
      } else {
        sdir = cross(normal, vec3(0,1,0));
      }
      tdir = cross(normal, sdir);
      return r*cos(angle)*sdir + r*sin(angle)*tdir + sqrt(1.-u)*normal;
    }

    Voxel nullVoxel = Voxel(vec3(0,0,0),vec3(1,1,1),vec3(1,0,1),false,0,0.5);

    Hit hitWorld(Ray ray){
      float minDist = 10000000.0;
      Voxel closestHit = nullVoxel;
      bool hasHit = false;
      for(int i = 0; i < 11; i++){
          vec2 hit = intersectVoxel(ray.origin,ray.direction,voxels[i].min,voxels[i].max);
          if(hit.x < hit.y && hit.y > 0.0){
            hasHit = true;
            if(hit.x < minDist){
              minDist = hit.x;
              closestHit = voxels[i];
            }
          }
      }
      return Hit(closestHit,minDist,hasHit);
    }

    vec3 sampleColor(Ray r, int sampleIndex){
      Ray ray = r;
      vec3 finalColor = vec3(0.0);
      vec3 finalReflec = vec3(1.0);
      float frac = 1.0;
      int bounceCount = 0;
      vec3 lighting = vec3(0.0);
      for(int depth = 0; depth< 3; depth++){
        Hit hit = hitWorld(ray);
        if(!hit.hasHit){
          //do world lighting
          if(depth==0){
            return worldColor(-ray.direction.y);
          }
          else{
            lighting = worldColor(-ray.direction.y);
            bounceCount = depth;
          }
          break;
        }
        if(length(hit.voxel.color) > 1.74){
          if(depth==0){
            return hit.voxel.color;
          }
          else{
            lighting = hit.voxel.color;
          }
          break;
        }
        vec3 hitPosition = rayPos(ray,hit.minDist);
        vec3 normal = getVoxelNormal(hitPosition,hit.voxel);
        hitPosition += normal*0.01;
        if(sampleIndex > 18 && depth<2){
          for(int j =0; j< 0; j++){
            vec3 shadowLDir = lights[j].position - hitPosition;
            vec3 originalDir = normalize(shadowLDir);
            float lDist = distance(hitPosition,lights[j].position);
            float hasHitS = 1.0;
              shadowLDir = lights[j].position - hitPosition + randVec(float(depth)+seed);
              Hit shadowHit = hitWorld(Ray(hitPosition,shadowLDir));
              if(shadowHit.hasHit){
                float rDist = distance(hitPosition,rayPos(Ray(hitPosition,shadowLDir),shadowHit.minDist));
                if(rDist < lDist){
                  hasHitS = 0.0;
                }
              }
            if(hasHitS!=0.0){
              lighting += lights[j].color * (1.0/pow(lDist,2.0)) * lights[j].intens * dot(normal, normalize(originalDir))*100.0*frac;
            }
          }
        }
        Hit directionalhit = hitWorld(Ray(hitPosition,vec3(sin(uTime),-0.9,1.0)+randVec(float(sampleIndex)+seed)*0.1));
        if(!directionalhit.hasHit){
          lighting += vec3(0.9,0.8,0.4);
        }
        vec3 localColor = hit.voxel.color+lighting;
        finalColor += localColor*frac;
        frac*=0.5;
        ray.origin = hitPosition;
        if(mod(float(sampleIndex),2.0)==0.0 && depth< 1){
        ray.direction = ray.direction - 2.0*dot(ray.direction,normal)*normal + randVec(float(depth)+seed*0.03)*0.03;
        }
        else{
          ray.direction = cosineWeightedDirection(float(depth)+seed*0.03, normal);
        }
      }
      seed++;
      return finalColor*lighting*pow(0.9,float(bounceCount));
    }
    

    



    
    void main() {
      initialize();
      vec3 accumulatedColor = vec3(0.0);
      for(int i =0; i< 10; i++){
        accumulatedColor += sampleColor(Ray(rays[0].origin,rays[0].direction+randVec(float(i))*0.003),i)*0.1;
      }
      gl_FragColor = vec4(accumulatedColor,1.0);
   }
</script>

<script>
    start_gl("canvas1", getStringFromDOMElement('vs'), getStringFromDOMElement('fs'));
</script>
